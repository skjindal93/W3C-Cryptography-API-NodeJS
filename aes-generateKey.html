<html>
<head>
	<script type="text/javascript" src="DJS/encoding.js"></script>
	<script type="text/javascript" src="DJS/hashing.js"></script>
	<script type="text/javascript" src="DJS/aes.js"></script>
	<script type="text/javascript" src="DJS/rsa.js"></script>
	<script type="text/javascript" src="functions.js"></script>
	<script type="text/javascript" src="algorithms.js"></script>
	<script type="text/javascript" src="Key.js"></script>
	<script type="text/javascript" src="generateKey.js"></script>
	<script type="text/javascript" src="sign.js"></script>
	<script type="text/javascript" src="decrypt.js"></script>
	<script type="text/javascript" src="encrypt.js"></script>
	<script type="text/javascript" src="exportKey.js"></script>
	<script type="text/javascript" src="importKey.js"></script>
	<script type="text/javascript" src="verify.js"></script>
	<script type="text/javascript" src="digest.js"></script>
	<script type="text/javascript" src="deriveKey.js"></script>
	<script type="text/javascript" src="wrapKey.js"></script>
	<script type="text/javascript" src="unwrapKey.js"></script>
	<script type="text/javascript" src="../chrome/resources/common.js"></script>
	<script type="text/javascript" src="../chrome/resources/js-test.js"></script>
	<script type="text/javascript" src="subtlecrypto.js"></script>
	
	<script type="text/javascript">
	function init(){
		
		var start = new Date().getTime();
		window.crypto = crypto;
		// Tests the 48 permutations of keys generated by:
		//   kPossibleAlgorithms x kPossibleExtractable x kPossibleKeyUsages x kPossibleKeyLengths
		//
		// For practical reasons these tests are not exhaustive.

		var kPossibleAlgorithms = ['AES-CBC'];
		var kPossibleExtractable = [true, false];
		var kPossibleKeyUsages = [['encrypt'], ['decrypt', 'wrapKey'], ['encrypt', 'wrapKey', 'unwrapKey']];
		var kPossibleKeyLengths = [128, 192, 256];

		// Set of all key data generated so far.
		var allKeyDataGenerated = {};

		function runTest(algorithmName, extractable, keyUsages, keyLengthBits)
		{
		    var genAlgorithm = { name: algorithmName, length: keyLengthBits };

		    var results = {};

		    var promise = crypto.subtle.generateKey(genAlgorithm, extractable, keyUsages).then(function(result) {
		        
		        generatedKey = result;

		        shouldEvaluateAs("generatedKey.extractable", extractable);
		        shouldEvaluateAs("generatedKey.algorithm.name", algorithmName);
		        shouldEvaluateAs("generatedKey.algorithm.length", keyLengthBits);
		        shouldEvaluateAs("generatedKey.usages.join(',')", keyUsages.join(","));

		        if (extractable){
		            return crypto.subtle.exportKey('raw', generatedKey);
		        }
		    });

		    if (extractable) {
		        promise = promise.then(function(result) {
		            keyData = result;
		            shouldEvaluateAs("keyData.byteLength", keyLengthBits / 8);

		            var keyDataHex = bytesToHexString(keyData);

		            // It is very unlikely to generate two identical keys, so
		            // assume if that happens something is broken.
		            // (8 extractable keys are generated for each bit length).
		            if (allKeyDataGenerated[keyDataHex]) {
		                testFailed("Generated identical key data: " + keyDataHex);
		            } else {
		                allKeyDataGenerated[keyDataHex] = true;
		                testPassed("Generated unique key data of length: " + (keyData.byteLength * 8) + " bits");
		            }
		        });
		    }

		    return promise;
		}

		var lastPromise = Promise.resolve(null);

		kPossibleAlgorithms.forEach(function(algorithmName) {
		    kPossibleExtractable.forEach(function(extractable) {
		        kPossibleKeyUsages.forEach(function(keyUsages) {
		            kPossibleKeyLengths.forEach(function(keyLengthBits) {
		                lastPromise = lastPromise.then(runTest.bind(null, algorithmName, extractable, keyUsages, keyLengthBits));
		            });
		        });
		    });
		});

		lastPromise.then(finishJSTest, failAndFinishJSTest);

	}
	</script>
</head>
<body onload="init()">
	
</body>
</html>